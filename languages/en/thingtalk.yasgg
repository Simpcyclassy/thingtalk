// -*- mode: js; indent-tabs-mode: nil; js-basic-offset: 4 -*-
//
// This file is part of ThingTalk
//
// Copyright 2017-2018 The Board of Trustees of the Leland Stanford Junior University
//
// Author: Giovanni Campagna <gcampagn@cs.stanford.edu>
//
// See COPYING for details

{
const assert = require('assert');

const Ast = require('../../lib/ast');
const Type = require('../../lib/type');
const Generate = require('../../lib/generate');
const { clean } = require('../../lib/utils');

const TIMER_SCHEMA = new Ast.FunctionDef('stream', 'timer', [], false, true, {}, {});
const AT_TIMER_SCHEMA = new Ast.FunctionDef('stream', 'attimer', [], false, true, {}, {});

// import the combinator library
const C = require('../../lib/sentence-generator/ast_manip');
}

import './constants';
import './filters';

for (let [pname, ptype] of $options.params.in.values()) {
    thingpedia_query = {
        q:thingpedia_query v:$('constant_' + ptype) [-> pname] => C.replacePlaceholderWithConstant(q, pname, v, C.betaReduceTable);
    }

    thingpedia_get_command = {
        q:thingpedia_get_command v:$('constant_' + ptype) [-> pname] => C.replacePlaceholderWithConstant(q, pname, v, C.betaReduceTable);
    }

    thingpedia_action = {
        q:thingpedia_action v:$('constant_' + ptype) [-> pname] => C.replacePlaceholderWithConstant(q, pname, v, C.betaReduceAction);
    }
}
/*
            let [pname,] = key.split('+');
            //if (!pname.startsWith('p_'))
            //    continue;
            //console.log(pname + ' := ' + ptype + ' ( ' + key + ' )');

            grammar.thingpedia_query.push(['${thingpedia_query}${constant_' + ptype + '}', replacePlaceholderWithConstant(pname, betaReduceTable)]);
            grammar.thingpedia_get_command.push(['${thingpedia_get_command}${constant_' + ptype + '}', replacePlaceholderWithConstant(pname, betaReduceTable)]);

            grammar.thingpedia_stream.push(['${thingpedia_stream}${constant_' + ptype + '}', replacePlaceholderWithConstant(pname, betaReduceStream)]);
            grammar.thingpedia_action.push(['${thingpedia_action}${constant_' + ptype + '}', replacePlaceholderWithConstant(pname, betaReduceAction)]);
*/

// out params nonterminals are automatically generated
out_param_Any = {}
out_param_Numeric = {}
out_param_Array__Any = {}

the_out_param_Numeric = {
    'the' p:out_param_Numeric => p;
    !turking {
        'its' p:out_param_Numeric => p;
        'their' p:out_param_Numeric => p;
    }
}
the_out_param_Array__Any = {
    'the' p:out_param_Array__Any => p;
    !turking {
        'its' p:out_param_Array__Any => p;
        'their' p:out_param_Array__Any => p;
    }
}
the_out_param_Date = {}
the_out_param_String = {}
out_param_Number = {}

// empty defaults for certain parameter types in case we don't have devices with
// those parameters
projection_Entity__tt__username = {}
projection_Entity__tt__email_address = {}


complete_table = {
    thingpedia_query if complete;
    table_join_replace_placeholder if complete;
    complete_get_command if complete;
}
if_filtered_table = {
    complete_table;
    one_filter_table;
    !turking two_filter_table;
}

one_filter_table = {
    table:complete_table 'if' filter:atom_filter => {
        if (!C.checkFilter(table, filter))
            return null;
        return C.addFilter(table, filter, $options);
    };
}
two_filter_table = {
    table:one_filter_table 'and' filter:atom_filter => {
        if (!C.checkFilter(table, filter))
            return null;
        return C.addFilter(table, filter, $options);
    };
}
with_filtered_table = {
    complete_table;

    table:complete_table choice('with', 'having') filter:with_filter => {
        if (!table.schema.is_list)
            return null;
        if (!C.checkFilter(table, filter))
            return null;
        return C.addFilter(table, filter, $options);
    };
}

timer = {
    'every day at' time:constant_Time => new Ast.Stream.AtTimer(time, AT_TIMER_SCHEMA);

    !turking {
        'every' interval:constant_Measure_ms => new Ast.Stream.Timer(Ast.Value.Date.now(), interval, TIMER_SCHEMA);
        'once in' interval:constant_Measure_ms => new Ast.Stream.Timer(Ast.Value.Date.now(), interval, TIMER_SCHEMA);
        'every day' => new Ast.Stream.Timer(Ast.Value.Date.now(), new Ast.Value.Measure(1, 'day'), TIMER_SCHEMA);
        'daily' => new Ast.Stream.Timer(Ast.Value.Date.now(), new Ast.Value.Measure(1, 'day'), TIMER_SCHEMA);
        'everyday' => new Ast.Stream.Timer(Ast.Value.Date.now(), new Ast.Value.Measure(1, 'day'), TIMER_SCHEMA);
        'once a day' => new Ast.Stream.Timer(Ast.Value.Date.now(), new Ast.Value.Measure(1, 'day'), TIMER_SCHEMA);
        'once a month' => new Ast.Stream.Timer(Ast.Value.Date.now(), new Ast.Value.Measure(1, 'mon'), TIMER_SCHEMA);
        'once a week' => new Ast.Stream.Timer(Ast.Value.Date.now(), new Ast.Value.Measure(1, 'week'), TIMER_SCHEMA);
        'once an hour' => new Ast.Stream.Timer(Ast.Value.Date.now(), new Ast.Value.Measure(1, 'h'), TIMER_SCHEMA);
        'daily at' time:constant_Time => new Ast.Stream.AtTimer(time, AT_TIMER_SCHEMA);
    }
}

// this is autogenerated and depends on projection_*, which is also
// autogenerated
projection_Any = {}
projection_Numeric = {}
stream_projection_Any = {}
table_join_replace_placeholder = {}

edge_stream = {
    !turking choice('when', 'if') 'the' p:projection_Any choice('becomes', 'becomes equal to') x:constant_Any => C.makeEdgeFilterStream(p, '==', x, $options);
    choice('when', 'if') 'the' p:projection_Numeric choice('becomes greater than', 'becomes higher than', 'goes above', 'increases above') x:constant_Numeric => C.makeEdgeFilterStream(p, '>=', x, $options);
    choice('when', 'if') 'the' p:projection_Numeric choice('becomes smaller than', 'becomes lower than', 'goes below', 'decreases below') x:constant_Numeric => C.makeEdgeFilterStream(p, '<=', x, $options);
}

stream = {
    thingpedia_stream if complete;
    !turking choice('when', 'if', 'in case', 'whenever', 'any time', 'should', 'anytime') table:with_filtered_table choice('change', 'update') => C.tableToStream(table, null);
    ?turking choice('when', 'if', 'in case', 'whenever', 'any time', 'should', 'anytime') table:with_filtered_table 'update' => C.tableToStream(table, null);

    !turking {
        choice('in case of changes', 'in case of variations', 'in case of updates', 'if something changes', 'when something changes', 'if there are changes', 'if there are updates') 'in' table:with_filtered_table => C.tableToStream(table, null);

        choice('when', 'if', 'in case', 'whenever', 'any time', 'anytime') proj:projection_Any 'changes' => {
            if (proj.args[0] === 'picture_url')
                return null;
            let outParams = Object.keys(proj.table.schema.out);
            let stream;
            if (outParams.length === 1 && $options.flags.turking)
                return null;
            if (outParams.length === 1)
                stream = C.tableToStream(proj.table, null);
            else
                stream = C.tableToStream(proj.table, proj.args);
            return stream;
        };
    }
    choice('when', 'if', 'in case', 'whenever', 'any time', 'should', 'anytime') table:complete_table 'change and' filter:edge_filter => {
        if (!table.schema.is_monitorable || !C.checkFilter(table, filter) || table.schema.is_list)
            return null;
        table = C.addFilter(table, filter, $options);
        if (!table)
            return null;
        return C.tableToStream(table, null);
    };
    choice('when', 'if', 'in case', 'whenever', 'any time', 'should', 'anytime') table:complete_table 'change and' filter:atom_filter => {
        if (!table.schema.is_monitorable || !C.checkFilter(table, filter))
            return null;
        if ($options.flags.turking && table.schema.is_list)
            return null;
        table = C.addFilter(table, filter, $options);
        if (!table)
            return null;
        return C.tableToStream(table, null);
    };
    edge_stream;
    timer;
}

action_replace_param_with_table = {}
action_replace_param_with_stream = {}

// FIXME add more...

complete_get_command = {}

$root = {
    // when => notify
    'notify me' stream:stream => C.makeProgram(new Ast.Statement.Rule(stream, [stream.isTimer || stream.isAtTimer ? C.builtinSayAction($options) : Generate.notifyAction()]));
}
